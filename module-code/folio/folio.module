<?php

/**
 * @file
 * Allows users to create and organize related content in an outline.
 */

/**
 * Implements hook_help().
 */
function folio_help($path, $arg) {
  switch ($path) {
    case 'admin/help#folio':
      $output = '<h3>' . t('About') . '</h3>';
      $output .= '<p>' . t('The folio module is used for creating structured, multi-page content, such as site resource guides, manuals, and wikis. It allows you to create content that has chapters, sections, subsections, or any similarly-tiered structure. For more information, see the online handfolio entry for <a href="@folio">folio module</a>.', array('@folio' => 'http://drupal.org/handfolio/modules/folio/')) . '</p>';
      $output .= '<h3>' . t('Uses') . '</h3>';
      $output .= '<dl>';
      $output .= '<dt>' . t('Adding and managing folio content') . '</dt>';
      $output .= '<dd>' . t('You can assign separate permissions for <em>creating</em>, <em>editing</em>, and <em>deleting</em> folio content, as well as <em>adding content to folios</em>, and <em>creating new folios</em>. Users with the <em>Administer folio outlines</em> permission can add <em>any</em> type of content to a folio by selecting the appropriate folio outline while editing the content. They can also view a list of all folios, and edit and rearrange section titles on the <a href="@admin-folio">folio administration page</a>.', array('@admin-folio' => url('admin/content/folio'))) . '</dd>';
      $output .= '<dt>' . t('folio navigation') . '</dt>';
      $output .= '<dd>' . t("folio pages have a default folio-specific navigation block. This navigation block contains links that lead to the previous and next pages in the folio, and to the level above the current page in the folio's structure. This block can be enabled on the <a href='@admin-block'>Blocks administration page</a>. For folio pages to show up in the folio navigation, they must be added to a folio outline.", array('@admin-block' => url('admin/structure/block'))) . '</dd>';
      $output .= '<dt>' . t('Collaboration') . '</dt>';
      $output .= '<dd>' . t('folios can be created collaboratively, as they allow users with appropriate permissions to add pages into existing folios, and add those pages to a custom table of contents menu.') . '</dd>';
      $output .= '<dt>' . t('Printing folios') . '</dt>';
      $output .= '<dd>' . t("Users with the <em>View printer-friendly folios</em> permission can select the <em>printer-friendly version</em> link visible at the bottom of a folio page's content to generate a printer-friendly display of the page and all of its subsections.") . '</dd>';
      $output .= '</dl>';
      return $output;
    case 'admin/content/folio':
      return '<p>' . t('The folio module offers a means to organize a collection of related content pages, collectively known as a folio. When viewed, this content automatically displays links to adjacent folio pages, providing a simple navigation system for creating and reviewing structured content.') . '</p>';
    case 'node/%/outline':
      return '<p>' . t('The outline feature allows you to include pages in the <a href="@folio">folio hierarchy</a>, as well as move them within the hierarchy or to <a href="@folio-admin">reorder an entire folio</a>.', array('@folio' => url('folio'), '@folio-admin' => url('admin/content/folio'))) . '</p>';
  }
}

/**
 * Implements hook_theme().
 */
function folio_theme() {
  return array(
    'folio_navigation' => array(
      'variables' => array('folio_link' => NULL),
      'template' => 'folio-navigation',
    ),
    'folio_export_html' => array(
      'variables' => array('title' => NULL, 'contents' => NULL, 'depth' => NULL),
      'template' => 'folio-export-html',
    ),
    'folio_admin_table' => array(
      'render element' => 'form',
    ),
    'folio_title_link' => array(
      'variables' => array('link' => NULL),
    ),
    'folio_all_folios_block' => array(
      'render element' => 'folio_menus',
      'template' => 'folio-all-folios-block',
    ),
    'folio_node_export_html' => array(
      'variables' => array('node' => NULL, 'children' => NULL),
      'template' => 'folio-node-export-html',
    ),
  );
}

/**
 * Implements hook_permission().
 */
function folio_permission() {
  return array(
    'administer folio outlines' => array(
      'title' => t('Administer folio outlines'),
    ),
    'create new folios' => array(
      'title' => t('Create new folios'),
    ),
    'add content to folios' => array(
      'title' => t('Add content and child pages to folios'),
    ),
    'access printer-friendly version' => array(
      'title' => t('View printer-friendly folios'),
      'description' => t('View a folio page and all of its sub-pages as a single document for ease of printing. Can be performance heavy.'),
    ),
  );
}

/**
 * Inject links into $node as needed.
 * Modified to remove std book links.
 */
function folio_node_view_link($node, $view_mode) {
  $links = array();
  if (!empty($links)) {
    $node->content['links']['folio'] = array(
      '#theme' => 'links__node__folio',
      '#links' => $links,
      '#attributes' => array('class' => array('links', 'inline')),
    );
  }
}


/**
 * Implements hook_menu().
 */
function folio_menu() {
  $items['admin/content/folio'] = array(
    'title' => 'folios',
    'description' => "Manage your site's folio outlines.",
    'page callback' => 'folio_admin_overview',
    'access arguments' => array('administer folio outlines'),
    'type' => MENU_LOCAL_TASK,
    'file' => 'folio.admin.inc',
  );
  $items['admin/content/folio/list'] = array(
    'title' => 'List',
    'type' => MENU_DEFAULT_LOCAL_TASK,
  );
  $items['admin/content/folio/settings'] = array(
    'title' => 'Settings',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('folio_admin_settings'),
    'access arguments' => array('administer site configuration'),
    'type' => MENU_LOCAL_TASK,
    'weight' => 8,
    'file' => 'folio.admin.inc',
  );
  $items['admin/content/folio/%node'] = array(
    'title' => 'Re-order folio pages and change titles',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('folio_admin_edit', 3),
    'access callback' => '_folio_outline_access',
    'access arguments' => array(3),
    'type' => MENU_CALLBACK,
    'file' => 'folio.admin.inc',
  );
  $items['folio'] = array(
    'title' => 'folios',
    'page callback' => 'folio_render',
    'access arguments' => array('access content'),
    'type' => MENU_SUGGESTED_ITEM,
    'file' => 'folio.pages.inc',
  );
  $items['folio/export/%/%'] = array(
    'page callback' => 'folio_export',
    'page arguments' => array(2, 3),
    'access arguments' => array('access printer-friendly version'),
    'type' => MENU_CALLBACK,
    'file' => 'folio.pages.inc',
  );
  $items['node/%node/contents'] = array(
    'title' => 'View folio contents',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('folio_content_edit', 1),
    'access callback' => '_folio_outline_access',
    'access arguments' => array(1),
    'type' => MENU_LOCAL_TASK,
    'weight' => 2,
    'file' => 'folio.admin.inc',
  );
  $items['node/%node/addchild'] = array(
    'title' => 'Add child page',
    'page callback' => 'folio_add_child',
    'page arguments' => array(1),
    'access callback' => '_folio_outline_access',
    'access arguments' => array(1),
    'type' => MENU_LOCAL_TASK,
    'weight' => 4,
    'file' => 'folio.admin.inc',
  );  
  $items['node/%node/outline/remove'] = array(
    'title' => 'Remove from outline',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('folio_remove_form', 1),
    'access callback' => '_folio_outline_remove_access',
    'access arguments' => array(1),
    'file' => 'folio.pages.inc',
  );

  return $items;
}

/**
 * Menu item access callback - determine if the outline tab is accessible.
 */
function _folio_outline_access($node) {
  return user_access('administer folio outlines') && node_access('view', $node);
}

/**
 * Menu item access callback - determine if the user can remove nodes from the outline.
 */
function _folio_outline_remove_access($node) {
  return isset($node->folio) && ($node->folio['bid'] != $node->nid) && _folio_outline_access($node);
}

/**
 * Implements hook_admin_paths().
 */
function folio_admin_paths() {
  if (variable_get('node_admin_theme')) {
    $paths = array(
      'node/*/outline' => TRUE,
      'node/*/outline/remove' => TRUE,
    );
    return $paths;
  }
}

/**
 * Implements hook_entity_info_alter().
 */
function folio_entity_info_alter(&$info) {
  // Add the 'Print' view mode for nodes.
  $info['node']['view modes'] += array(
    'print' => array(
      'label' => t('Print'),
      'custom settings' => FALSE,
    ),
  );
}

/**
 * Implements hook_block_info().
 */
function folio_block_info() {
  $block = array();
  $block['navigation']['info'] = t('folio navigation');
  $block['navigation']['cache'] = DRUPAL_CACHE_PER_PAGE | DRUPAL_CACHE_PER_ROLE;

  return $block;
}

/**
 * Implements hook_block_view().
 *
 * Displays the folio table of contents in a block when the current page is a
 * single-node view of a folio node.
 */
function folio_block_view($delta = '') {
  $block = array();
  $current_bid = 0;
  if ($node = menu_get_object()) {
    $current_bid = empty($node->folio['bid']) ? 0 : $node->folio['bid'];
  }

  if (variable_get('folio_block_mode', 'all pages') == 'all pages') {
    $block['subject'] = t('folio navigation');
    $folio_menus = array();
    $pseudo_tree = array(0 => array('below' => FALSE));
    foreach (folio_get_folios() as $folio_id => $folio) {
      if ($folio['bid'] == $current_bid) {
        // If the current page is a node associated with a folio, the menu
        // needs to be retrieved.
        $folio_menus[$folio_id] = menu_tree_output(menu_tree_all_data($node->folio['menu_name'], $node->folio));
      }
      else {
        // Since we know we will only display a link to the top node, there
        // is no reason to run an additional menu tree query for each folio.
        $folio['in_active_trail'] = FALSE;
        // Check whether user can access the folio link.
        $folio_node = node_load($folio['nid']);
        $folio['access'] = node_access('view', $folio_node);
        $pseudo_tree[0]['link'] = $folio;
        $folio_menus[$folio_id] = menu_tree_output($pseudo_tree);
      }
    }
    $folio_menus['#theme'] = 'folio_all_folios_block';
    $block['content'] = $folio_menus;
  }
  elseif ($current_bid) {
    // Only display this block when the user is browsing a folio.
  $select = db_select('node', 'n')
    ->fields('n', array('title'))
    ->condition('n.nid', $node->folio['bid'])
    ->addTag('node_access');
    $title = $select->execute()->fetchField();
    // Only show the block if the user has view access for the top-level node.
    if ($title) {
      $tree = menu_tree_all_data($node->folio['menu_name'], $node->folio);
      // There should only be one element at the top level.
      $data = array_shift($tree);
      $block['subject'] = theme('folio_title_link', array('link' => $data['link']));
      $block['content'] = ($data['below']) ? menu_tree_output($data['below']) : '';
    }
  }

  return $block;
}

/**
 * Implements hook_block_configure().
 */
function folio_block_configure($delta = '') {
  $block = array();
  $options = array(
    'all pages' => t('Show block on all pages'),
    'folio pages' => t('Show block only on folio pages'),
  );
  $form['folio_block_mode'] = array(
    '#type' => 'radios',
    '#title' => t('folio navigation block display'),
    '#options' => $options,
    '#default_value' => variable_get('folio_block_mode', 'all pages'),
    '#description' => t("If <em>Show block on all pages</em> is selected, the block will contain the automatically generated menus for all of the site's folios. If <em>Show block only on folio pages</em> is selected, the block will contain only the one menu corresponding to the current page's folio. In this case, if the current page is not in a folio, no block will be displayed. The <em>Page specific visibility settings</em> or other visibility settings can be used in addition to selectively display this block."),
    );

  return $form;
}

/**
 * Implements hook_block_save().
 */
function folio_block_save($delta = '', $edit = array()) {
  $block = array();
  variable_set('folio_block_mode', $edit['folio_block_mode']);
}

/**
 * Returns HTML for a link to a folio title when used as a block title.
 *
 * @param $variables
 *   An associative array containing:
 *   - link: An array containing title, href and options for the link.
 *
 * @ingroup themeable
 */
function theme_folio_title_link($variables) {
  $link = $variables['link'];

  $link['options']['attributes']['class'] = array('folio-title');

  return l($link['title'], $link['href'], $link['options']);
}

/**
 * Returns an array of all folios.
 *
 * This list may be used for generating a list of all the folios, or for building
 * the options for a form select.
 */
function folio_get_folios() {
  $all_folios = &drupal_static(__FUNCTION__);

  if (!isset($all_folios)) {
    $all_folios = array();
    $nids = db_query("SELECT DISTINCT(bid) FROM {folio}")->fetchCol();

    if ($nids) {
      $query = db_select('folio', 'f', array('fetch' => PDO::FETCH_ASSOC));
      $query->join('node', 'n', 'f.nid = n.nid');
      $query->join('menu_links', 'ml', 'f.mlid = ml.mlid');
      $query->addField('n', 'type', 'type');
      $query->addField('n', 'title', 'title');
      $query->fields('f');
      $query->fields('ml');
      $query->condition('n.nid', $nids, 'IN');
      $query->condition('n.status', 1);
      $query->orderBy('ml.weight');
      $query->orderBy('ml.link_title');
      $query->addTag('node_access');
      $result2 = $query->execute();
      foreach ($result2 as $link) {
        $link['href'] = $link['link_path'];
        $link['options'] = unserialize($link['options']);
        $all_folios[$link['bid']] = $link;
      }
    }
  }

  return $all_folios;
}

/**
 * Implements hook_form_BASE_FORM_ID_alter().
 *
 * Adds the folio fieldset to the node form.
 *
 * @see folio_pick_folio_nojs_submit()
 */
function folio_form_node_form_alter(&$form, &$form_state, $form_id) {
  $node = $form['#node'];
  $access = user_access('administer folio outlines');
  if (!$access) {
    if (user_access('add content to folios') && ((!empty($node->folio['mlid']) && !empty($node->nid)) || folio_type_is_allowed($node->type))) {
      // Already in the folio hierarchy, or this node type is allowed.
      $access = TRUE;
    }
  }

  if ($access) {
    _folio_add_form_elements($form, $form_state, $node);
    // Since the "folio" dropdown can't trigger a form submission when
    // JavaScript is disabled, add a submit button to do that. folio.css hides
    // this button when JavaScript is enabled.
    $form['folio']['pick-folio'] = array(
      '#type' => 'submit',
      '#value' => t('Change folio (update list of parents)'),
      '#submit' => array('folio_pick_folio_nojs_submit'),
      '#weight' => 20,
    );
  }
}

/**
 * Submit handler to change a node's folio.
 *
 * This handler is run when JavaScript is disabled. It triggers the form to
 * rebuild so that the "Parent item" options are changed to reflect the newly
 * selected folio. When JavaScript is enabled, the submit button that triggers
 * this handler is hidden, and the "folio" dropdown directly triggers the
 * folio_form_update() Ajax callback instead.
 *
 * @see folio_form_update()
 */
function folio_pick_folio_nojs_submit($form, &$form_state) {
  $form_state['node']->folio = $form_state['values']['folio'];
  $form_state['rebuild'] = TRUE;
}

/**
 * Build the parent selection form element for the node form or outline tab.
 *
 * This function is also called when generating a new set of options during the
 * Ajax callback, so an array is returned that can be used to replace an existing
 * form element.
 */
function _folio_parent_select($folio_link) {
  if (variable_get('menu_override_parent_selector', FALSE)) {
    return array();
  }
  // Offer a message or a drop-down to choose a different parent page.
  $form = array(
    '#type' => 'hidden',
    '#value' => -1,
    '#prefix' => '<div id="edit-folio-plid-wrapper">',
    '#suffix' => '</div>',
  );

  if ($folio_link['nid'] === $folio_link['bid']) {
    // This is a folio - at the top level.
    if ($folio_link['original_bid'] === $folio_link['bid']) {
      $form['#prefix'] .= '<em>' . t('This is the top-level page in this folio.') . '</em>';
    }
    else {
      $form['#prefix'] .= '<em>' . t('This will be the top-level page in this folio.') . '</em>';
    }
  }
  elseif (!$folio_link['bid']) {
    $form['#prefix'] .= '<em>' . t('No folio selected.') . '</em>';
  }
  else {
    $form = array(
      '#type' => 'select',
      '#title' => t('Parent item'),
      '#default_value' => $folio_link['plid'],
      '#description' => t('The parent page in the folio. The maximum depth for a folio and all child pages is !maxdepth. Some pages in the selected folio may not be available as parents if selecting them would exceed this limit.', array('!maxdepth' => MENU_MAX_DEPTH)),
      '#options' => folio_toc($folio_link['bid'], $folio_link['parent_depth_limit'], array($folio_link['mlid'])),
      '#attributes' => array('class' => array('folio-title-select')),
      '#prefix' => '<div id="edit-folio-plid-wrapper">',
      '#suffix' => '</div>',
    );
  }

  return $form;
}

/**
 * Build the common elements of the folio form for the node and outline forms.
 */
function _folio_add_form_elements(&$form, &$form_state, $node) {
  // If the form is being processed during the Ajax callback of our folio bid
  // dropdown, then $form_state will hold the value that was selected.
  if (isset($form_state['values']['folio'])) {
    $node->folio = $form_state['values']['folio'];
  }

  $form['folio'] = array(
    '#type' => 'fieldset',
    '#title' => t('folio outline'),
    '#weight' => 10,
    '#collapsible' => TRUE,
    '#collapsed' => TRUE,
    '#group' => 'additional_settings',
    '#attributes' => array(
      'class' => array('folio-form'),
    ),
    '#attached' => array(
      'js' => array(drupal_get_path('module', 'folio') . '/folio.js'),
    ),
    '#tree' => TRUE,
    '#attributes' => array('class' => array('folio-outline-form')),
  );
  foreach (array('menu_name', 'mlid', 'nid', 'router_path', 'has_children', 'options', 'module', 'original_bid', 'parent_depth_limit') as $key) {
    $form['folio'][$key] = array(
      '#type' => 'value',
      '#value' => $node->folio[$key],
    );
  }

  $form['folio']['plid'] = _folio_parent_select($node->folio);

  // @see _folio_admin_table_tree(). The weight may be larger than 15.
  $form['folio']['weight'] = array(
    '#type' => 'weight',
    '#title' => t('Weight'),
    '#default_value' => $node->folio['weight'],
    '#delta' => max(15, abs($node->folio['weight'])),
    '#weight' => 5,
    '#description' => t('Pages at a given level are ordered first by weight and then by title.'),
  );
  $options = array();
  $nid = isset($node->nid) ? $node->nid : 'new';

  if (isset($node->nid) && ($nid == $node->folio['original_bid']) && ($node->folio['parent_depth_limit'] == 0)) {
    // This is the top level node in a maximum depth folio and thus cannot be moved.
    $options[$node->nid] = $node->title;
  }
  else {
    foreach (folio_get_folios() as $folio) {
      $options[$folio['nid']] = $folio['title'];
    }
  }

  if (user_access('create new folios') && ($nid == 'new' || ($nid != $node->folio['original_bid']))) {
    // The node can become a new folio, if it is not one already.
    $options = array($nid => '<' . t('create a new folio') . '>') + $options;
  }
  if (!$node->folio['mlid']) {
    // The node is not currently in the hierarchy.
    $options = array(0 => '<' . t('none') . '>') + $options;
  }

  // Add a drop-down to select the destination folio.
  $form['folio']['bid'] = array(
    '#type' => 'select',
    '#title' => t('folio'),
    '#default_value' => $node->folio['bid'],
    '#options' => $options,
    '#access' => (bool) $options,
    '#description' => t('Your page will be a part of the selected folio.'),
    '#weight' => -5,
    '#attributes' => array('class' => array('folio-title-select')),
    '#ajax' => array(
      'callback' => 'folio_form_update',
      'wrapper' => 'edit-folio-plid-wrapper',
      'effect' => 'fade',
      'speed' => 'fast',
    ),
  );
}

/**
 * Renders a new parent page select element when the folio selection changes.
 *
 * This function is called via Ajax when the selected folio is changed on a node
 * or folio outline form.
 *
 * @return
 *   The rendered parent page select element.
 */
function folio_form_update($form, $form_state) {
  return $form['folio']['plid'];
}

/**
 * Common helper function to handles additions and updates to the folio outline.
 *
 * Performs all additions and updates to the folio outline through node addition,
 * node editing, node deletion, or the outline tab.
 */
function _folio_update_outline($node) {
  if (empty($node->folio['bid'])) {
    return FALSE;
  }
  $new = empty($node->folio['mlid']);

  $node->folio['link_path'] = 'node/' . $node->nid;
  $node->folio['link_title'] = $node->title;
  $node->folio['parent_mismatch'] = FALSE; // The normal case.

  if ($node->folio['bid'] == $node->nid) {
    $node->folio['plid'] = 0;
    $node->folio['menu_name'] = folio_menu_name($node->nid);
  }
  else {
    // Check in case the parent is not is this folio; the folio takes precedence.
    if (!empty($node->folio['plid'])) {
      $parent = db_query("SELECT * FROM {folio} WHERE mlid = :mlid", array(
        ':mlid' => $node->folio['plid'],
      ))->fetchAssoc();
    }
    if (empty($node->folio['plid']) || !$parent || $parent['bid'] != $node->folio['bid']) {
      $node->folio['plid'] = db_query("SELECT mlid FROM {folio} WHERE nid = :nid", array(
        ':nid' => $node->folio['bid'],
      ))->fetchField();
      $node->folio['parent_mismatch'] = TRUE; // Likely when JS is disabled.
    }
  }

  if (menu_link_save($node->folio)) {
    if ($new) {
      // Insert new.
      db_insert('folio')
        ->fields(array(
          'nid' => $node->nid,
          'mlid' => $node->folio['mlid'],
          'bid' => $node->folio['bid'],
        ))
        ->execute();
      // Reset the cache of stored folios.
      drupal_static_reset('folio_get_folios');
    }
    else {
      if ($node->folio['bid'] != db_query("SELECT bid FROM {folio} WHERE nid = :nid", array(
          ':nid' => $node->nid,
        ))->fetchField()) {
        // Update the bid for this page and all children.
        folio_update_bid($node->folio);
        // Reset the cache of stored folios.
        drupal_static_reset('folio_get_folios');
      }
    }

    return TRUE;
  }

  // Failed to save the menu link.
  return FALSE;
}

/**
 * Update the bid for a page and its children when it is moved to a new folio.
 *
 * @param $folio_link
 *   A fully loaded menu link that is part of the folio hierarchy.
 */
function folio_update_bid($folio_link) {
  $query = db_select('menu_links');
  $query->addField('menu_links', 'mlid');
  for ($i = 1; $i <= MENU_MAX_DEPTH && $folio_link["p$i"]; $i++) {
    $query->condition("p$i", $folio_link["p$i"]);
  }
  $mlids = $query->execute()->fetchCol();

  if ($mlids) {
    db_update('folio')
      ->fields(array('bid' => $folio_link['bid']))
      ->condition('mlid', $mlids, 'IN')
      ->execute();
  }
}

/**
 * Get the folio menu tree for a page, and return it as a linear array.
 *
 * @param $folio_link
 *   A fully loaded menu link that is part of the folio hierarchy.
 * @return
 *   A linear array of menu links in the order that the links are shown in the
 *   menu, so the previous and next pages are the elements before and after the
 *   element corresponding to $node. The children of $node (if any) will come
 *   immediately after it in the array, and links will only be fetched as deep
 *   as one level deeper than $folio_link.
 */
function folio_get_flat_menu($folio_link) {
  $flat = &drupal_static(__FUNCTION__, array());

  if (!isset($flat[$folio_link['mlid']])) {
    // Call menu_tree_all_data() to take advantage of the menu system's caching.
    $tree = menu_tree_all_data($folio_link['menu_name'], $folio_link, $folio_link['depth'] + 1);
    $flat[$folio_link['mlid']] = array();
    _folio_flatten_menu($tree, $flat[$folio_link['mlid']]);
  }

  return $flat[$folio_link['mlid']];
}

/**
 * Recursive helper function for folio_get_flat_menu().
 */
function _folio_flatten_menu($tree, &$flat) {
  foreach ($tree as $data) {
    if (!$data['link']['hidden']) {
      $flat[$data['link']['mlid']] = $data['link'];
      if ($data['below']) {
        _folio_flatten_menu($data['below'], $flat);
      }
    }
  }
}

/**
 * Fetches the menu link for the previous page of the folio.
 */
function folio_prev($folio_link) {
  // If the parent is zero, we are at the start of a folio.
  if ($folio_link['plid'] == 0) {
    return NULL;
  }
  $flat = folio_get_flat_menu($folio_link);
  // Assigning the array to $flat resets the array pointer for use with each().
  $curr = NULL;
  do {
    $prev = $curr;
    list($key, $curr) = each($flat);
  } while ($key && $key != $folio_link['mlid']);

  if ($key == $folio_link['mlid']) {
    // The previous page in the folio may be a child of the previous visible link.
    if ($prev['depth'] == $folio_link['depth'] && $prev['has_children']) {
      // The subtree will have only one link at the top level - get its data.
      $tree = folio_menu_subtree_data($prev);
      $data = array_shift($tree);
      // The link of interest is the last child - iterate to find the deepest one.
      while ($data['below']) {
        $data = end($data['below']);
      }

      return $data['link'];
    }
    else {
      return $prev;
    }
  }
}

/**
 * Fetches the menu link for the next page of the folio.
 */
function folio_next($folio_link) {
  $flat = folio_get_flat_menu($folio_link);
  // Assigning the array to $flat resets the array pointer for use with each().
  do {
    list($key, $curr) = each($flat);
  }
  while ($key && $key != $folio_link['mlid']);

  if ($key == $folio_link['mlid']) {
    return current($flat);
  }
}

/**
 * Format the menu links for the child pages of the current page.
 */
function folio_children($folio_link) {
  $flat = folio_get_flat_menu($folio_link);

  $children = array();

  if ($folio_link['has_children']) {
    // Walk through the array until we find the current page.
    do {
      $link = array_shift($flat);
    }
    while ($link && ($link['mlid'] != $folio_link['mlid']));
    // Continue though the array and collect the links whose parent is this page.
    while (($link = array_shift($flat)) && $link['plid'] == $folio_link['mlid']) {
      $data['link'] = $link;
      $data['below'] = '';
      $children[] = $data;
    }
  }

  if ($children) {
    $elements = menu_tree_output($children);
    return drupal_render($elements);
  }
  return '';
}

/**
 * Generate the corresponding menu name from a folio ID.
 */
function folio_menu_name($bid) {
  return 'folio-toc-' . $bid;
}

/**
 * Implements hook_node_load().
 */
function folio_node_load($nodes, $types) {
  $result = db_query("SELECT * FROM {folio} f INNER JOIN {menu_links} ml ON f.mlid = ml.mlid WHERE f.nid IN (:nids)", array(':nids' =>  array_keys($nodes)), array('fetch' => PDO::FETCH_ASSOC));
  foreach ($result as $record) {
    $nodes[$record['nid']]->folio = $record;
    $nodes[$record['nid']]->folio['href'] = $record['link_path'];
    $nodes[$record['nid']]->folio['title'] = $record['link_title'];
    $nodes[$record['nid']]->folio['options'] = unserialize($record['options']);
  }
}

/**
 * Implements hook_node_view().
 */
function folio_node_view($node, $view_mode) {
  if ($view_mode == 'full') {
    if (!empty($node->folio['bid']) && empty($node->in_preview)) {
      $node->content['folio_navigation'] = array(
        '#markup' => theme('folio_navigation', array('folio_link' => $node->folio)),
        '#weight' => 100,
      );
    }
  }

  if ($view_mode != 'rss') {
    folio_node_view_link($node, $view_mode);
  }
}

/**
 * Implements hook_page_alter().
 *
 * Add the folio menu to the list of menus used to build the active trail when
 * viewing a folio page.
 */
function folio_page_alter(&$page) {
  if (($node = menu_get_object()) && !empty($node->folio['bid'])) {
    $active_menus = menu_get_active_menu_names();
    $active_menus[] = $node->folio['menu_name'];
    menu_set_active_menu_names($active_menus);
  }
}

/**
 * Implements hook_node_presave().
 */
function folio_node_presave($node) {
  // Always save a revision for non-administrators.
  if (!empty($node->folio['bid']) && !user_access('administer nodes')) {
    $node->revision = 1;
    // The database schema requires a log message for every revision.
    if (!isset($node->log)) {
      $node->log = '';
    }
  }
  // Make sure a new node gets a new menu link.
  if (empty($node->nid)) {
    $node->folio['mlid'] = NULL;
  }
}

/**
 * Implements hook_node_insert().
 */
function folio_node_insert($node) {
  if (!empty($node->folio['bid'])) {
    if ($node->folio['bid'] == 'new') {
      // New nodes that are their own folio.
      $node->folio['bid'] = $node->nid;
    }
    $node->folio['nid'] = $node->nid;
    $node->folio['menu_name'] = folio_menu_name($node->folio['bid']);
    _folio_update_outline($node);
  }
}

/**
 * Implements hook_node_update().
 */
function folio_node_update($node) {
  if (!empty($node->folio['bid'])) {
    if ($node->folio['bid'] == 'new') {
      // New nodes that are their own folio.
      $node->folio['bid'] = $node->nid;
    }
    $node->folio['nid'] = $node->nid;
    $node->folio['menu_name'] = folio_menu_name($node->folio['bid']);
    _folio_update_outline($node);
  }
}

/**
 * Implements hook_node_delete().
 */
function folio_node_delete($node) {
  if (!empty($node->folio['bid'])) {
    if ($node->nid == $node->folio['bid']) {
      // Handle deletion of a top-level post.
      $result = db_query("SELECT f.nid FROM {menu_links} ml INNER JOIN {folio} f on f.mlid = ml.mlid WHERE ml.plid = :plid", array(
        ':plid' => $node->folio['mlid']
      ));
      foreach ($result as $child) {
        $child_node = node_load($child->nid);
        $child_node->folio['bid'] = $child_node->nid;
        _folio_update_outline($child_node);
      }
    }
    menu_link_delete($node->folio['mlid']);
    db_delete('folio')
      ->condition('mlid', $node->folio['mlid'])
      ->execute();
    drupal_static_reset('folio_get_folios');
  }
}

/**
 * Implements hook_node_prepare().
 */
function folio_node_prepare($node) {
  // Prepare defaults for the add/edit form.
  if (empty($node->folio) && (user_access('add content to folios') || user_access('administer folio outlines'))) {
    $node->folio = array();

    if (empty($node->nid) && isset($_GET['parent']) && is_numeric($_GET['parent'])) {
      // Handle "Add child page" links:
      $parent = folio_link_load($_GET['parent']);

      if ($parent && $parent['access']) {
        $node->folio['bid'] = $parent['bid'];
        $node->folio['plid'] = $parent['mlid'];
        $node->folio['menu_name'] = $parent['menu_name'];
      }
    }
    // Set defaults.
    $node->folio += _folio_link_defaults(!empty($node->nid) ? $node->nid : 'new');
  }
  else {
    if (isset($node->folio['bid']) && !isset($node->folio['original_bid'])) {
      $node->folio['original_bid'] = $node->folio['bid'];
    }
  }
  // Find the depth limit for the parent select.
  if (isset($node->folio['bid']) && !isset($node->folio['parent_depth_limit'])) {
    $node->folio['parent_depth_limit'] = _folio_parent_depth_limit($node->folio);
  }
}

/**
 * Find the depth limit for items in the parent select.
 */
function _folio_parent_depth_limit($folio_link) {
  return MENU_MAX_DEPTH - 1 - (($folio_link['mlid'] && $folio_link['has_children']) ? menu_link_children_relative_depth($folio_link) : 0);
}

/**
 * Form altering function for the confirm form for a single node deletion.
 */
function folio_form_node_delete_confirm_alter(&$form, $form_state) {
  $node = node_load($form['nid']['#value']);

  if (isset($node->folio) && $node->folio['has_children']) {
    $form['folio_warning'] = array(
      '#markup' => '<p>' . t('%title is part of a folio outline, and has associated child pages. If you proceed with deletion, the child pages will be relocated automatically.', array('%title' => $node->title)) . '</p>',
      '#weight' => -10,
    );
  }
}

/**
 * Return an array with default values for a folio link.
 */
function _folio_link_defaults($nid) {
  return array('original_bid' => 0, 'menu_name' => '', 'nid' => $nid, 'bid' => 0, 'router_path' => 'node/%', 'plid' => 0, 'mlid' => 0, 'has_children' => 0, 'weight' => 0, 'module' => 'folio', 'options' => array());
}

/**
 * Process variables for folio-all-folios-block.tpl.php.
 *
 * The $variables array contains the following arguments:
 * - $folio_menus
 *
 * All non-renderable elements are removed so that the template has full
 * access to the structured data but can also simply iterate over all
 * elements and render them (as in the default template).
 *
 * @see folio-navigation.tpl.php
 */
function template_preprocess_folio_all_folios_block(&$variables) {
  // Remove all non-renderable elements.
  $elements = $variables['folio_menus'];
  $variables['folio_menus'] = array();
  foreach (element_children($elements) as $index) {
    $variables['folio_menus'][$index] = $elements[$index];
  }
}

/**
 * Process variables for folio-navigation.tpl.php.
 *
 * The $variables array contains the following arguments:
 * - $folio_link
 *
 * @see folio-navigation.tpl.php
 */
function template_preprocess_folio_navigation(&$variables) {
  $folio_link = $variables['folio_link'];

  // Provide extra variables for themers. Not needed by default.
  $variables['folio_id'] = $folio_link['bid'];
  $variables['folio_title'] = check_plain($folio_link['link_title']);
  $variables['folio_url'] = 'node/' . $folio_link['bid'];
  $variables['current_depth'] = $folio_link['depth'];
  $variables['tree'] = '';

  if ($folio_link['mlid']) {
    $variables['tree'] = folio_children($folio_link);

    if ($prev = folio_prev($folio_link)) {
      $prev_href = url($prev['href']);
      drupal_add_html_head_link(array('rel' => 'prev', 'href' => $prev_href));
      $variables['prev_url'] = $prev_href;
      $variables['prev_title'] = check_plain($prev['title']);
    }

    if ($folio_link['plid'] && $parent = folio_link_load($folio_link['plid'])) {
      $parent_href = url($parent['href']);
      drupal_add_html_head_link(array('rel' => 'up', 'href' => $parent_href));
      $variables['parent_url'] = $parent_href;
      $variables['parent_title'] = check_plain($parent['title']);
    }

    if ($next = folio_next($folio_link)) {
      $next_href = url($next['href']);
      drupal_add_html_head_link(array('rel' => 'next', 'href' => $next_href));
      $variables['next_url'] = $next_href;
      $variables['next_title'] = check_plain($next['title']);
    }
  }

  $variables['has_links'] = FALSE;
  // Link variables to filter for values and set state of the flag variable.
  $links = array('prev_url', 'prev_title', 'parent_url', 'parent_title', 'next_url', 'next_title');
  foreach ($links as $link) {
    if (isset($variables[$link])) {
      // Flag when there is a value.
      $variables['has_links'] = TRUE;
    }
    else {
      // Set empty to prevent notices.
      $variables[$link] = '';
    }
  }
}

/**
 * Recursively processes and formats menu items for folio_toc().
 *
 * This helper function recursively modifies the $toc array for each item in
 * $tree, ignoring items in the exclude array or at a depth greater than the
 * limit.  Truncates titles over thirty characters and appends an indentation
 * string incremented by depth.
 *
 * @param $tree
 *   The data structure of the folio's menu tree.  Includes hidden links.
 * @param $indent
 *   A string appended to each menu item title. Increments by '--' per depth
 *   level.
 * @param $toc
 *   Reference to the table of contents array. This is modified in place, so the
 *   function does not have a return value.
 * @param $exclude
 *   Optional array of mlid values. Any link whose mlid is in this array will be
 *   excluded (along with its children).
 * @param $depth_limit
 *   Any link deeper than this value will be excluded (along with its children).
 */
function _folio_toc_recurse($tree, $indent, &$toc, $exclude, $depth_limit) {
  foreach ($tree as $data) {
    if ($data['link']['depth'] > $depth_limit) {
      // Don't iterate through any links on this level.
      break;
    }

    if (!in_array($data['link']['mlid'], $exclude)) {
      $toc[$data['link']['mlid']] = $indent . ' ' . truncate_utf8($data['link']['title'], 30, TRUE, TRUE);
      if ($data['below']) {
        _folio_toc_recurse($data['below'], $indent . '--', $toc, $exclude, $depth_limit);
      }
    }
  }
}

/**
 * Returns an array of folio pages in table of contents order.
 *
 * @param $bid
 *   The ID of the folio whose pages are to be listed.
 * @param $depth_limit
 *   Any link deeper than this value will be excluded (along with its children).
 * @param $exclude
 *   Optional array of mlid values. Any link whose mlid is in this array
 *   will be excluded (along with its children).
 * @return
 *   An array of mlid, title pairs for use as options for selecting a folio page.
 */
function folio_toc($bid, $depth_limit, $exclude = array()) {
  $tree = menu_tree_all_data(folio_menu_name($bid));
  $toc = array();
  _folio_toc_recurse($tree, '', $toc, $exclude, $depth_limit);

  return $toc;
}

/**
 * Process variables for folio-export-html.tpl.php.
 *
 * The $variables array contains the following arguments:
 * - $title
 * - $contents
 * - $depth
 *
 * @see folio-export-html.tpl.php
 */
function template_preprocess_folio_export_html(&$variables) {
  global $base_url, $language;

  $variables['title'] = check_plain($variables['title']);
  $variables['base_url'] = $base_url;
  $variables['language'] = $language;
  $variables['language_rtl'] = ($language->direction == LANGUAGE_RTL);
  $variables['head'] = drupal_get_html_head();
}

/**
 * Traverse the folio tree to build printable or exportable output.
 *
 * During the traversal, the $visit_func() callback is applied to each
 * node, and is called recursively for each child of the node (in weight,
 * title order).
 *
 * @param $tree
 *   A subtree of the folio menu hierarchy, rooted at the current page.
 * @param $visit_func
 *   A function callback to be called upon visiting a node in the tree.
 * @return
 *   The output generated in visiting each node.
 */
function folio_export_traverse($tree, $visit_func) {
  $output = '';

  foreach ($tree as $data) {
    // Note- access checking is already performed when building the tree.
    if ($node = node_load($data['link']['nid'], FALSE)) {
      $children = '';

      if ($data['below']) {
        $children = folio_export_traverse($data['below'], $visit_func);
      }

      if (function_exists($visit_func)) {
        $output .= call_user_func($visit_func, $node, $children);
      }
      else {
        // Use the default function.
        $output .= folio_node_export($node, $children);
      }
    }
  }

  return $output;
}

/**
 * Generates printer-friendly HTML for a node.
 *
 * @see folio_export_traverse()
 *
 * @param $node
 *   The node that will be output.
 * @param $children
 *   All the rendered child nodes within the current node.
 * @return
 *   The HTML generated for the given node.
 */
function folio_node_export($node, $children = '') {
  $build = node_view($node, 'print');
  unset($build['#theme']);
  // @todo Rendering should happen in the template using render().
  $node->rendered = drupal_render($build);

  return theme('folio_node_export_html', array('node' => $node, 'children' => $children));
}

/**
 * Process variables for folio-node-export-html.tpl.php.
 *
 * The $variables array contains the following arguments:
 * - $node
 * - $children
 *
 * @see folio-node-export-html.tpl.php
 */
function template_preprocess_folio_node_export_html(&$variables) {
  $variables['depth'] = $variables['node']->folio['depth'];
  $variables['title'] = check_plain($variables['node']->title);
  $variables['content'] = $variables['node']->rendered;
}

/**
 * Determine if a given node type is in the list of types allowed for folios.
 */
function folio_type_is_allowed($type) {
  return in_array($type, variable_get('folio_allowed_types', array('folio')));
}

/**
 * Implements hook_node_type_update().
 *
 * Update folio module's persistent variables if the machine-readable name of a
 * node type is changed.
 */
function folio_node_type_update($type) {
  if (!empty($type->old_type) && $type->old_type != $type->type) {
    // Update the list of node types that are allowed to be added to folios.
    $allowed_types = variable_get('folio_allowed_types', array('folio'));
    $key = array_search($type->old_type, $allowed_types);

    if ($key !== FALSE) {
      $allowed_types[$type->type] = $allowed_types[$key] ? $type->type : 0;
      unset($allowed_types[$key]);
      variable_set('folio_allowed_types', $allowed_types);
    }

    // Update the setting for the "Add child page" link.
    if (variable_get('folio_child_type', 'folio') == $type->old_type) {
      variable_set('folio_child_type', $type->type);
    }
  }
}

/**
 * Like menu_link_load(), but adds additional data from the {folio} table.
 *
 * Do not call when loading a node, since this function may call node_load().
 */
function folio_link_load($mlid) {
  if ($item = db_query("SELECT * FROM {menu_links} ml INNER JOIN {folio} f ON f.mlid = ml.mlid LEFT JOIN {menu_router} m ON m.path = ml.router_path WHERE ml.mlid = :mlid", array(
      ':mlid' => $mlid,
    ))->fetchAssoc()) {
    _menu_link_translate($item);
    return $item;
  }

  return FALSE;
}

/**
 * Get the data representing a subtree of the folio hierarchy.
 *
 * The root of the subtree will be the link passed as a parameter, so the
 * returned tree will contain this item and all its descendents in the menu tree.
 *
 * @param $link
 *   A fully loaded menu link.
 * @return
 *   An subtree of menu links in an array, in the order they should be rendered.
 */
function folio_menu_subtree_data($link) {
  $tree = &drupal_static(__FUNCTION__, array());

  // Generate a cache ID (cid) specific for this $menu_name and $link.
  $cid = 'links:' . $link['menu_name'] . ':subtree-cid:' . $link['mlid'];

  if (!isset($tree[$cid])) {
    $cache = cache_get($cid, 'cache_menu');

    if ($cache && isset($cache->data)) {
      // If the cache entry exists, it will just be the cid for the actual data.
      // This avoids duplication of large amounts of data.
      $cache = cache_get($cache->data, 'cache_menu');

      if ($cache && isset($cache->data)) {
        $data = $cache->data;
      }
    }

    // If the subtree data was not in the cache, $data will be NULL.
    if (!isset($data)) {
      $query = db_select('menu_links', 'ml', array('fetch' => PDO::FETCH_ASSOC));
      $query->join('menu_router', 'm', 'm.path = ml.router_path');
      $query->join('folio', 'f', 'ml.mlid = f.mlid');
      $query->fields('f');
      $query->fields('m', array('load_functions', 'to_arg_functions', 'access_callback', 'access_arguments', 'page_callback', 'page_arguments', 'delivery_callback', 'title', 'title_callback', 'title_arguments', 'type'));
      $query->fields('ml');
      $query->condition('menu_name', $link['menu_name']);
      for ($i = 1; $i <= MENU_MAX_DEPTH && $link["p$i"]; ++$i) {
        $query->condition("p$i", $link["p$i"]);
      }
      for ($i = 1; $i <= MENU_MAX_DEPTH; ++$i) {
        $query->orderBy("p$i");
      }
      $links = array();
      foreach ($query->execute() as $item) {
        $links[] = $item;
      }
      $data['tree'] = menu_tree_data($links, array(), $link['depth']);
      $data['node_links'] = array();
      menu_tree_collect_node_links($data['tree'], $data['node_links']);
      // Compute the real cid for folio subtree data.
      $tree_cid = 'links:' . $item['menu_name'] . ':subtree-data:' . hash('sha256', serialize($data));
      // Cache the data, if it is not already in the cache.

      if (!cache_get($tree_cid, 'cache_menu')) {
        cache_set($tree_cid, $data, 'cache_menu');
      }
      // Cache the cid of the (shared) data using the menu and item-specific cid.
      cache_set($cid, $tree_cid, 'cache_menu');
    }
    // Check access for the current user to each item in the tree.
    menu_tree_check_access($data['tree'], $data['node_links']);
    $tree[$cid] = $data['tree'];
  }

  return $tree[$cid];
}
